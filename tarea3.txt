Tarea 3: Servicio de Gestión de Planes (Integrado)
Objetivo: Implementar servicio para gestionar planes usando las tablas extendidas.
Prompt para el agente IA:
Implementa TaskPlanService en gateway/app/services/task_plan_service.py que funcione con el db.py modificado:

```python
from typing import List, Optional, Dict, Any
import json
from datetime import datetime

from app.db import db, TaskPlanDB, TaskDB, ProjectDB
from app.models.core import Project

class TaskPlanService:
    """Service for managing versioned task plans."""
    
    def __init__(self):
        self.db = db  # Usar la instancia global
    
    def create_plan(self, project_id: str, tasks_json: List[Dict], created_by: str = 'ai') -> TaskPlanDB:
        """Create new plan version with tasks."""
        # 1. Obtener versión más alta actual
        with self.db.get_session() as session:
            from sqlmodel import select, func
            stmt = select(func.max(TaskPlanDB.version)).where(TaskPlanDB.project_id == project_id)
            max_version = session.exec(stmt).first() or 0
        
        # 2. Crear nuevo plan
        plan = TaskPlanDB(
            project_id=project_id,
            version=max_version + 1,
            status="proposed",
            summary=f"Plan v{max_version + 1} generado",
            created_by=created_by
        )
        plan = self.db.create_task_plan(plan)
        
        # 3. Crear tareas asociadas
        for idx, task_data in enumerate(tasks_json):
            task = TaskDB(
                project_id=project_id,
                plan_id=plan.id,
                idx=idx,
                code=task_data.get('code', f'T-{idx+1:03d}'),
                task_id=task_data.get('code', f'T-{idx+1:03d}'),  # Mantener compatibilidad
                title=task_data.get('title', 'Sin título'),
                description=task_data.get('description', ''),
                acceptance=task_data.get('acceptance_criteria', ''),
                status='pending',
                deps_json=json.dumps(task_data.get('dependencies', [])),
                mcp_tools=json.dumps(task_data.get('mcp_tools', [])),
                deliverables=json.dumps(task_data.get('deliverables', [])),
                estimates=json.dumps(task_data.get('estimates', {})),
                priority=task_data.get('priority', 1)
            )
            self.db.add_task(task)
        
        # 4. Exportar a JSON (sincronización con disco)
        self._export_plan_to_json(project_id, plan)
        
        return plan
    
    def accept_plan(self, plan_id: int) -> TaskPlanDB:
        """Accept a plan and mark previous plans as superseded."""
        with self.db.get_session() as session:
            from sqlmodel import select
            
            # Obtener el plan
            plan = session.get(TaskPlanDB, plan_id)
            if not plan:
                raise ValueError(f"Plan {plan_id} not found")
            
            # Marcar otros planes del proyecto como superseded
            stmt = select(TaskPlanDB).where(
                TaskPlanDB.project_id == plan.project_id,
                TaskPlanDB.id != plan_id,
                TaskPlanDB.status == "accepted"
            )
            for old_plan in session.exec(stmt):
                old_plan.status = "superseded"
                session.add(old_plan)
            
            # Aceptar el plan actual
            plan.status = "accepted"
            session.add(plan)
            
            # Actualizar proyecto
            project = session.get(ProjectDB, plan.project_id)
            if project:
                project.active_plan_id = plan_id
                if project.status == "draft" or project.status == "consensus":
                    project.status = "active"
                session.add(project)
            
            session.commit()
            session.refresh(plan)
            
        return plan
    
    def _export_plan_to_json(self, project_id: str, plan: TaskPlanDB):
        """Export plan to JSON file for inspection."""
        from pathlib import Path
        import json
        
        plans_dir = Path(f"projects/{project_id}/plans")
        plans_dir.mkdir(parents=True, exist_ok=True)
        
        # Obtener tareas del plan
        with self.db.get_session() as session:
            from sqlmodel import select
            stmt = select(TaskDB).where(TaskDB.plan_id == plan.id).order_by(TaskDB.idx)
            tasks = session.exec(stmt).all()
        
        plan_data = {
            "version": plan.version,
            "status": plan.status,
            "summary": plan.summary,
            "created_by": plan.created_by,
            "created_at": plan.created_at.isoformat(),
            "tasks": [
                {
                    "code": t.code or t.task_id,
                    "title": t.title,
                    "description": t.description,
                    "dependencies": json.loads(t.deps_json or "[]"),
                    "mcp_tools": json.loads(t.mcp_tools or "[]"),
                    "deliverables": json.loads(t.deliverables or "[]"),
                    "estimates": json.loads(t.estimates or "{}"),
                    "priority": t.priority
                }
                for t in tasks
            ]
        }
        
        plan_file = plans_dir / f"plan_v{plan.version}.json"
        with open(plan_file, 'w', encoding='utf-8') as f:
            json.dump(plan_data, f, indent=2, ensure_ascii=False)
    
    # ... más métodos según la arquitectura propuesta
Tests en gateway/tests/test_task_plan_service.py usando pytest


*Contexto General de la Arquitectura
Estamos construyendo un sistema de gestión de desarrollo de videojuegos asistido por IA que:
Gestiona proyectos con planes de tareas versionados
Mantiene contexto evolutivo (global y por tarea)
Coordina agentes IA con herramientas MCP
Permite consenso usuario-IA en la planificación
Genera y actualiza contexto automáticamente

*Buenas Prácticas para la Implementación
Base de Datos: Usar siempre `data/gateway.db`
Principios SOLID: Cada componente con responsabilidad única
Idempotencia: Operaciones repetibles sin efectos secundarios
Versionado Semántico: Cambios compatibles hacia atrás
Transacciones Atómicas: Todo o nada en operaciones críticas
Logging Estructurado: Trazabilidad completa con correlation IDs
Eventos: WebSocket para actualizaciones en tiempo real
Tests Unitarios: Mínimo 80% cobertura en lógica de negocio
Documentación API: OpenAPI actualizado con cada cambio