Tarea 4: Sistema de Contexto (Integrado con BD Existente)

**Objetivo**: Implementar gestión de contexto usando las tablas extendidas.

**Prompt para el agente IA**:
Crea ContextService en gateway/app/services/context_service.py integrado con el db.py extendido:
pythonfrom typing import Optional, Dict, Any, List
import json
from datetime import datetime

from app.db import db, ContextDB, TaskDB, ProjectDB, SessionDB, ArtifactDB

class ContextService:
    """Service for managing versioned context."""
    
    def __init__(self):
        self.db = db  # Usar instancia global
    
    def get_active_context(self, project_id: str, scope: str = 'global', task_id: Optional[int] = None) -> Optional[Dict]:
        """Get active context content as dict."""
        context_db = self.db.get_active_context(project_id, scope)
        if context_db:
            try:
                return json.loads(context_db.content)
            except:
                return None
        return None
    
    def create_context(self, 
                      project_id: str, 
                      content: Dict[str, Any], 
                      scope: str = 'global',
                      task_id: Optional[int] = None,
                      created_by: str = 'system') -> ContextDB:
        """Create new context version."""
        
        # Obtener versión actual
        with self.db.get_session() as session:
            from sqlmodel import select, func
            stmt = select(func.max(ContextDB.version)).where(
                ContextDB.project_id == project_id,
                ContextDB.scope == scope
            )
            if scope == 'task' and task_id:
                stmt = stmt.where(ContextDB.task_id == task_id)
            
            max_version = session.exec(stmt).first() or 0
        
        # Crear nuevo contexto
        context = ContextDB(
            project_id=project_id,
            scope=scope,
            task_id=task_id if scope == 'task' else None,
            content=json.dumps(content, ensure_ascii=False),
            created_by=created_by,
            source='manual-edit' if created_by == 'user' else 'ai-generate',
            version=max_version + 1,
            is_active=True
        )
        
        context = self.db.create_context(context)
        
        # Sincronizar con archivos
        self._sync_context_to_files(project_id, scope, content, task_id)
        
        return context
    
    def generate_context_after_task(self, project_id: str, task_id: int) -> Dict[str, Any]:
        """Generate context after task completion."""
        
        # Obtener información necesaria
        task = self.db.get_task(task_id)
        if not task:
            raise ValueError(f"Task {task_id} not found")
        
        # Contexto global actual
        global_context = self.get_active_context(project_id, 'global') or {}
        
        # Actualizar lista de tareas completadas
        done_tasks = global_context.get('done_tasks', [])
        if task.code and task.code not in done_tasks:
            done_tasks.append(task.code)
        
        # Obtener siguiente tarea disponible
        next_task = self._get_next_available_task(project_id)
        
        # Contar tareas pendientes
        all_tasks = self.db.list_tasks(project_id)
        pending_count = len([t for t in all_tasks if t.status != 'done'])
        
        # Construir nuevo contexto global
        new_global_context = {
            "version": global_context.get('version', 0) + 1,
            "current_task": next_task.code if next_task else None,
            "done_tasks": done_tasks,
            "pending_tasks": pending_count,
            "summary": global_context.get('summary', '') + f"\nCompletada tarea {task.code}: {task.title}",
            "decisions": global_context.get('decisions', []),
            "open_questions": global_context.get('open_questions', []),
            "risks": global_context.get('risks', []),
            "last_update": datetime.utcnow().isoformat()
        }
        
        # Guardar nuevo contexto
        self.create_context(project_id, new_global_context, scope='global', created_by='system')
        
        return new_global_context
    
    def _get_next_available_task(self, project_id: str) -> Optional[TaskDB]:
        """Get next task with all dependencies completed."""
        tasks = self.db.list_tasks(project_id)
        
        for task in tasks:
            if task.status != 'pending':
                continue
            
            # Verificar dependencias
            if task.deps_json:
                deps = json.loads(task.deps_json)
                deps_met = True
                for dep_code in deps:
                    dep_task = next((t for t in tasks if t.code == dep_code or t.task_id == dep_code), None)
                    if not dep_task or dep_task.status != 'done':
                        deps_met = False
                        break
                
                if deps_met:
                    return task
            else:
                # Sin dependencias, disponible
                return task
        
        return None
    
    def _sync_context_to_files(self, project_id: str, scope: str, content: Dict, task_id: Optional[int] = None):
        """Sync context to filesystem."""
        from pathlib import Path
        
        if scope == 'global':
            context_dir = Path(f"projects/{project_id}/context")
            context_dir.mkdir(parents=True, exist_ok=True)
            
            # Guardar contexto activo
            active_file = context_dir / "active_context.json"
            with open(active_file, 'w', encoding='utf-8') as f:
                json.dump(content, f, indent=2, ensure_ascii=False)
            
            # Guardar en historial
            history_dir = context_dir / "history"
            history_dir.mkdir(exist_ok=True)
            version = content.get('version', 1)
            history_file = history_dir / f"context_v{version}.json"
            with open(history_file, 'w', encoding='utf-8') as f:
                json.dump(content, f, indent=2, ensure_ascii=False)
        
        elif scope == 'task' and task_id:
            task = self.db.get_task(task_id)
            if task and task.code:
                task_dir = Path(f"projects/{project_id}/context/task/{task.code}")
                task_dir.mkdir(parents=True, exist_ok=True)
                
                active_file = task_dir / "active.json"
                with open(active_file, 'w', encoding='utf-8') as f:
                    json.dump(content, f, indent=2, ensure_ascii=False)
Incluir integración con el sistema de sesiones existente para recuperar contexto de mensajes anteriores.



*Contexto General de la Arquitectura
Estamos construyendo un sistema de gestión de desarrollo de videojuegos asistido por IA que:
Gestiona proyectos con planes de tareas versionados
Mantiene contexto evolutivo (global y por tarea)
Coordina agentes IA con herramientas MCP
Permite consenso usuario-IA en la planificación
Genera y actualiza contexto automáticamente

*Buenas Prácticas para la Implementación
Base de Datos: Usar siempre `data/gateway.db`
Principios SOLID: Cada componente con responsabilidad única
Idempotencia: Operaciones repetibles sin efectos secundarios
Versionado Semántico: Cambios compatibles hacia atrás
Transacciones Atómicas: Todo o nada en operaciones críticas
Logging Estructurado: Trazabilidad completa con correlation IDs
Eventos: WebSocket para actualizaciones en tiempo real
Tests Unitarios: Mínimo 80% cobertura en lógica de negocio
Documentación API: OpenAPI actualizado con cada cambio