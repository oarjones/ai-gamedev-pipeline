Tarea 6: Flujo de Ejecución de Tareas Mejorado

**Objetivo**: Sistema inteligente de selección y ejecución de tareas.

**Prompt para el agente IA**:
Crea gateway/app/services/task_execution_service.py integrado con servicios existentes:
pythonfrom typing import Optional, List, Dict, Any, AsyncGenerator
import json
import asyncio
from datetime import datetime

from app.db import db, TaskDB, ProjectDB
from app.services.context_service import ContextService
from app.services.unified_agent import agent as unified_agent
from app.ws.events import manager
from app.models import Envelope, EventType

class TaskExecutionService:
    """Service for intelligent task execution flow."""
    
    def __init__(self):
        self.db = db
        self.context_service = ContextService()
    
    def get_next_available_task(self, project_id: str) -> Optional[TaskDB]:
        """Get next task with all dependencies completed."""
        tasks = self.db.list_tasks(project_id)
        
        # Ordenar por prioridad y story points
        def task_score(t):
            estimates = json.loads(t.estimates or '{}')
            story_points = estimates.get('story_points', 5)
            return (t.priority, -story_points, t.idx)
        
        available_tasks = []
        
        for task in tasks:
            if task.status != 'pending':
                continue
            
            # Verificar dependencias
            deps_met = True
            if task.deps_json:
                deps = json.loads(task.deps_json)
                for dep_code in deps:
                    dep_task = next(
                        (t for t in tasks if t.code == dep_code or t.task_id == dep_code), 
                        None
                    )
                    if not dep_task or dep_task.status != 'done':
                        deps_met = False
                        break
            
            if deps_met:
                available_tasks.append(task)
        
        if available_tasks:
            return min(available_tasks, key=task_score)
        return None
    
    async def start_task(self, task_id: int) -> TaskDB:
        """Start a task execution."""
        task = self.db.update_task(
            task_id,
            status='in_progress',
            started_at=datetime.utcnow()
        )
        
        if not task:
            raise ValueError(f"Task {task_id} not found")
        
        # Actualizar proyecto
        with self.db.get_session() as session:
            project = session.get(ProjectDB, task.project_id)
            if project:
                project.current_task_id = task_id
                session.add(project)
                session.commit()
        
        # Emitir evento
        await self._emit_task_event(task, "task.started")
        
        return task
    
    async def complete_task(self, task_id: int, evidence: List[Dict] = None) -> TaskDB:
        """Complete a task and update context."""
        task = self.db.update_task(
            task_id,
            status='done',
            completed_at=datetime.utcnow(),
            evidence_json=json.dumps(evidence or [])
        )
        
        if not task:
            raise ValueError(f"Task {task_id} not found")
        
        # Generar nuevo contexto
        try:
            new_context = self.context_service.generate_context_after_task(
                task.project_id, 
                task_id
            )
        except Exception as e:
            print(f"Error generating context: {e}")
        
        # Seleccionar siguiente tarea
        next_task = self.get_next_available_task(task.project_id)
        if next_task:
            await self.start_task(next_task.id)
        
        # Emitir evento
        await self._emit_task_event(task, "task.completed", {
            "next_task": next_task.code if next_task else None
        })
        
        return task
    
    async def execute_task_with_agent(self, task_id: int) -> AsyncGenerator[Dict, None]:
        """Execute task with agent assistance."""
        task = self.db.get_task(task_id)
        if not task:
            raise ValueError(f"Task {task_id} not found")
        
        # Construir contexto
        global_context = self.context_service.get_active_context(task.project_id, 'global')
        task_context = self.context_service.get_active_context(
            task.project_id, 
            'task', 
            task_id
        )
        
        # Construir prompt
        mcp_tools = json.loads(task.mcp_tools or '[]')
        deliverables = json.loads(task.deliverables or '[]')
        
        prompt = f"""
        CONTEXTO GLOBAL DEL PROYECTO:
        {json.dumps(global_context, indent=2, ensure_ascii=False)}
        
        TAREA ACTUAL: {task.code} - {task.title}
        Descripción: {task.description}
        
        CRITERIOS DE ACEPTACIÓN:
        {task.acceptance}
        
        HERRAMIENTAS MCP SUGERIDAS: {', '.join(mcp_tools)}
        
        ENTREGABLES ESPERADOS:
        {json.dumps(deliverables, indent=2, ensure_ascii=False)}
        
        {f"CONTEXTO DE TAREA ANTERIOR: {json.dumps(task_context, indent=2, ensure_ascii=False)}" if task_context else ""}
        
        Por favor, ejecuta esta tarea paso a paso, usando las herramientas MCP necesarias.
        Documenta cada paso y verifica que se cumplan los criterios de aceptación.
        """
        
        # Enviar al agente
        from pathlib import Path
        cwd = Path("projects") / task.project_id
        
        if not unified_agent.status().running:
            await unified_agent.start(cwd, 'gemini')
        
        response = await unified_agent.send(prompt, correlation_id=f"task-{task_id}")
        
        yield {"type": "started", "task_id": task_id}
        
        # Stream de respuestas (simplificado)
        yield {"type": "response", "content": response}
    
    async def verify_acceptance_criteria(self, task_id: int) -> Dict[str, Any]:
        """Use AI to verify if acceptance criteria are met."""
        task = self.db.get_task(task_id)
        if not task:
            raise ValueError(f"Task {task_id} not found")
        
        # Obtener evidencia
        evidence = json.loads(task.evidence_json or '[]')
        
        prompt = f"""
        Verifica si se cumplen los siguientes criterios de aceptación:
        
        TAREA: {task.title}
        CRITERIOS: {task.acceptance}
        
        EVIDENCIA DISPONIBLE:
        {json.dumps(evidence, indent=2, ensure_ascii=False)}
        
        Responde con JSON:
        {{
            "criteria_met": true/false,
            "details": [
                {{"criterion": "...", "met": true/false, "notes": "..."}}
            ],
            "recommendation": "..."
        }}
        """
        
        # Llamar al agente para verificación
        from pathlib import Path
        cwd = Path("projects") / task.project_id
        
        if not unified_agent.status().running:
            await unified_agent.start(cwd, 'gemini')
        
        await unified_agent.send(prompt, correlation_id=f"verify-{task_id}")
        
        return {"status": "verification_requested", "task_id": task_id}
    
    async def _emit_task_event(self, task: TaskDB, event_type: str, extra_data: Dict = None):
        """Emit task event via WebSocket."""
        payload = {
            "event": event_type,
            "task": {
                "id": task.id,
                "code": task.code or task.task_id,
                "title": task.title,
                "status": task.status
            }
        }
        if extra_data:
            payload.update(extra_data)
        
        envelope = Envelope(
            type=EventType.UPDATE,
            projectId=task.project_id,
            payload=payload
        )
        
        await manager.broadcast_project(
            task.project_id, 
            envelope.model_dump_json()
        )

# Instancia global
task_execution_service = TaskExecutionService()



*Contexto General de la Arquitectura
Estamos construyendo un sistema de gestión de desarrollo de videojuegos asistido por IA que:
Gestiona proyectos con planes de tareas versionados
Mantiene contexto evolutivo (global y por tarea)
Coordina agentes IA con herramientas MCP
Permite consenso usuario-IA en la planificación
Genera y actualiza contexto automáticamente

*Buenas Prácticas para la Implementación
Base de Datos: Usar siempre `data/gateway.db`
Principios SOLID: Cada componente con responsabilidad única
Idempotencia: Operaciones repetibles sin efectos secundarios
Versionado Semántico: Cambios compatibles hacia atrás
Transacciones Atómicas: Todo o nada en operaciones críticas
Logging Estructurado: Trazabilidad completa con correlation IDs
Eventos: WebSocket para actualizaciones en tiempo real
Tests Unitarios: Mínimo 80% cobertura en lógica de negocio
Documentación API: OpenAPI actualizado con cada cambio