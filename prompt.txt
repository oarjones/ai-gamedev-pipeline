Tarea 10 — UI del Chat (streaming, adjuntos, tool-calls visibles)

Contexto
El chat es el centro de interacción. Debe soportar envío de mensajes, streaming (chunks type=chat), markdown básico y adjuntos (imágenes de screenshots). Debe visualizar tool-calls si llegan por WS.

Objetivo
Implementar ChatPane con: lista de mensajes (roles user|agent|system|tool), input con Enter, render de markdown, soporte de adjuntos (imágenes) y escucha WS para eventos type=chat y type=tool. Integrar POST /api/v1/chat/send.

Alcance y tareas

lib/api.ts: helper sendChat({projectId, text}) usando fetch (manejo de errores).

ChatPane:

Input controlado con Enter para enviar (sendChat).

Lista de mensajes con burbujas estilizadas (role-based).

Render markdown (seguro) + botón “copiar”.

Adjuntos: <img> cuando message.attachments[].type==='image' (data URL o URL segura).

Suscribirse a WS de rooms por projectId y append de:

type=chat (role=agent/user/system) con content por chunks; merge visible.

type=tool (mostrar badge “tool-call” + payload colapsable).

Estado sending y toasts de error.

Entregables

components/chat/ChatPane.tsx con UI completa.

lib/api.ts con sendChat.

lib/markdown.ts (sanitización/render).

Añadir hooks mínimos (useChatStream(projectId)).

Restricciones

Virtualized list si >200 mensajes (ej. react-virtuoso o propio).

Sanitizar HTML en markdown (no ejecutar scripts).

Manejo de reconexión WS (reintentos con backoff simple).

Criterios de aceptación (DoD)

Enviar texto produce evento chat (eco o real) visible en pantalla (stream si aplica).

Si llega screenshot_ready como adjunto, se renderiza la imagen inline.

Los tool-calls (type=tool) se ven como bloques colapsables con payload.

Buenas prácticas

Accesibilidad: ARIA roles en lista y controles, foco gestionado.

Auto-scroll al final solo si el usuario está ya al final (no romper lectura histórica).

Separar MessageItem y MessageList; memoizar.

Evitar any; usar zod para validar payloads de WS antes de pintar.